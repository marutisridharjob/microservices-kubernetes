step-by-step guide to deploy your Spring Boot project into Kubernetes.

1. Prerequisites

Before deploying to Kubernetes, ensure the following:
	1.	Kubernetes cluster is set up (local like Minikube or cloud-based like GKE/EKS/AKS).
	2.	kubectl CLI is installed and configured to access the cluster.
	3.	Docker is installed to build container images.

 2. Prepare the Application

2.1 Create the Dockerfile

Add a Dockerfile in your Spring Boot project root directory:

# Use OpenJDK 17 image as base
FROM openjdk:17-jdk-slim
VOLUME /tmp
ARG JAR_FILE=target/demo-0.0.1-SNAPSHOT.jar
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java", "-jar", "/app.jar"]

2.2 Package the Application

Use Maven to package the application:

mvn clean package

This will generate the JAR file in the target directory.

2.3 Build the Docker Image

Build a Docker image using the Dockerfile:


docker build -t springboot-k8s-demo:1.0 .

2.4 Test the Docker Image Locally

Run the Docker container locally to ensure it works:

docker run -p 8080:8080 springboot-k8s-demo:1.0

Visit http://localhost:8080/api/test-cases to verify.

3. Push the Docker Image to a Container Registry

You need to push your Docker image to a registry accessible by the Kubernetes cluster (e.g., Docker Hub, AWS ECR, GCP Artifact Registry).

3.1 Log in to Docker Hub

docker login

3.2 Tag the Docker Image

Tag the image with your Docker Hub repository name:

docker tag springboot-k8s-demo:1.0 <your-dockerhub-username>/springboot-k8s-demo:1.0

3.3 Push the Image

Push the image to Docker Hub:

docker push <your-dockerhub-username>/springboot-k8s-demo:1.0

4. Create Kubernetes Deployment and Service YAML Files

4.1 Deployment YAML

Create deployment.yaml for deploying your application:

apiVersion: apps/v1
kind: Deployment
metadata:
  name: springboot-k8s-demo
  labels:
    app: springboot-k8s-demo
spec:
  replicas: 2
  selector:
    matchLabels:
      app: springboot-k8s-demo
  template:
    metadata:
      labels:
        app: springboot-k8s-demo
    spec:
      containers:
      - name: springboot-k8s-demo
        image: <your-dockerhub-username>/springboot-k8s-demo:1.0
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_DATASOURCE_URL
          value: jdbc:db2://<db-host>:<db-port>/<db-name>
        - name: SPRING_DATASOURCE_USERNAME
          value: <db-username>
        - name: SPRING_DATASOURCE_PASSWORD
          value: <db-password>


Replace <your-dockerhub-username>, <db-host>, <db-port>, <db-name>, <db-username>, and <db-password> with your values.


4.2 Service YAML

Create service.yaml for exposing the application:

apiVersion: v1
kind: Service
metadata:
  name: springboot-k8s-demo-service
spec:
  selector:
    app: springboot-k8s-demo
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: LoadBalancer



5. Deploy to Kubernetes

5.1 Apply Deployment

Deploy the application:


kubectl apply -f deployment.yaml



5.2 Apply Service

Expose the application:

kubectl apply -f service.yaml


5.3 Verify Deployment

Check if pods are running:

kubectl get pods


kubectl get pods


Check if the service is running:

kubectl get svc

6. Access the Application

	•	For local clusters (e.g., Minikube), use the following command to expose the service:

 minikube service springboot-k8s-demo-service

 It will open the application in your browser.

	•	For cloud clusters, check the external IP of the service:

 kubectl get svc

 Access the application at http://<external-ip>/api/test-cases.

 7. Environment Variables in Kubernetes (Optional)

To avoid hardcoding sensitive database credentials in the YAML file, you can use Kubernetes Secrets and ConfigMaps.

7.1 Create Secrets for Database Credentials


kubectl create secret generic db-credentials \
  --from-literal=username=<db-username> \
  --from-literal=password=<db-password>


  7.2 Update Deployment to Use Secrets

Modify the deployment.yaml file:

env:
- name: SPRING_DATASOURCE_URL
  value: jdbc:db2://<db-host>:<db-port>/<db-name>
- name: SPRING_DATASOURCE_USERNAME
  valueFrom:
    secretKeyRef:
      name: db-credentials
      key: username
- name: SPRING_DATASOURCE_PASSWORD
  valueFrom:
    secretKeyRef:
      name: db-credentials
      key: password


8. Scaling the Application

To scale the application horizontally:

kubectl scale deployment springboot-k8s-demo --replicas=5

9. Monitoring and Logs

	•	Check Logs for a Pod:

 kubectl logs <pod-name>


 
	•	Describe a Deployment or Pod:

 kubectl describe deployment springboot-k8s-demo
kubectl describe pod <pod-name>

10. Clean Up

If you want to delete the deployment and service:

kubectl delete -f deployment.yaml
kubectl delete -f service.yaml


----------

Kubernetes deployments can be made asynchronous or synchronous based on the use case and the interaction with the database schema:
	1.	Asynchronous Deployment:
	•	Ideal for microservices that do not depend on immediate database readiness.
	•	Ensure the service is resilient to temporary unavailability of dependencies (e.g., database schema migrations still running).
	•	Use readiness and liveness probes to control when the service is ready to handle requests.
	2.	Synchronous Deployment:
	•	Necessary if schema migrations or database setups are critical before the application starts.
	•	A pre-hook (e.g., initContainers) can handle schema updates to ensure consistency before the main app is deployed.

In both cases, validate schema compatibility during CI/CD to avoid runtime conflicts.


Here’s an example of asynchronous Kubernetes deployment YAML based on this morning’s instructions. It ensures that the service is deployed asynchronously with proper readiness and liveness probes.

Deployment YAML


apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-service
  labels:
    app: my-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-service
  template:
    metadata:
      labels:
        app: my-service
    spec:
      containers:
      - name: my-service-container
        image: my-service:latest
        ports:
        - containerPort: 8080
        readinessProbe:
          httpGet:
            path: /health/readiness
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /health/liveness
            port: 8080
          initialDelaySeconds: 10
          periodSeconds: 15
        env:
        - name: DB_URL
          value: "jdbc:postgresql://my-database:5432/mydb"
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: my-db-secret
              key: username
        - name: DB_PASS
          valueFrom:
            secretKeyRef:
              name: my-db-secret
              key: password


Service YAML

apiVersion: v1
kind: Service
metadata:
  name: my-service
  labels:
    app: my-service
spec:
  ports:
  - port: 8080
    targetPort: 8080
  selector:
    app: my-service
  type: ClusterIP


Asynchronous Considerations

	1.	Readiness Probe ensures the service only starts serving traffic when it’s fully ready (e.g., after connecting to the database).
	2.	Liveness Probe ensures the service restarts if it becomes unresponsive.
	3.	Decoupling: Database readiness and schema migrations are managed separately, e.g., through a Job or external migration tool like Flyway.

Let me know if you need a Job YAML for schema migrations or further clarification!




